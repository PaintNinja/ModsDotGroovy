package org.groovymc.modsdotgroovy.gradle.tasks

import groovy.json.JsonSlurper
import groovy.transform.CompileStatic
import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.Directory
import org.gradle.api.file.ProjectLayout
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.services.ServiceReference
import org.gradle.api.tasks.*
import org.gradle.work.NormalizeLineEndings
import org.groovymc.modsdotgroovy.types.core.Platform
import org.groovymc.modsdotgroovy.gradle.internal.MapUtils
import org.groovymc.modsdotgroovy.gradle.internal.ConvertService
import org.groovymc.modsdotgroovy.types.runner.FilteredStream
import org.jetbrains.annotations.ApiStatus

import javax.inject.Inject
import java.nio.file.Files

@CacheableTask
@CompileStatic
abstract class AbstractMDGConvertTask extends DefaultTask {

    @InputFile
    @NormalizeLineEndings
    @PathSensitive(PathSensitivity.NONE)
    abstract RegularFileProperty getInput()

    @OutputFile
    abstract RegularFileProperty getOutput()

    // included in the output file name
    @Internal
    abstract Property<String> getOutputName()

    @CompileClasspath
    abstract ConfigurableFileCollection getMdgRuntimeFiles()

    @Input
    @Optional
    abstract MapProperty<String, Object> getBuildProperties()

    @Input
    @Optional
    abstract Property<Platform> getPlatform()

    @Input
    abstract Property<Boolean> getIsMultiplatform()

    @Input
    abstract Property<String> getProjectVersion()

    @Input
    abstract Property<String> getProjectGroup()

    /**
     * A file containing platform-specific details, such as the Minecraft version and loader version.
     * <p>Generated by a task that extends {@link AbstractGatherPlatformDetailsTask}</p>
     */
    @InputFile
    @NormalizeLineEndings
    @PathSensitive(PathSensitivity.NONE)
    abstract RegularFileProperty getPlatformDetailsFile()

    @Inject
    protected abstract ProjectLayout getProjectLayout()

    @ServiceReference('org.groovymc.modsdotgroovy.gradle.internal.ConvertService')
    @ApiStatus.Internal
    protected abstract Property<ConvertService> getConvertService()

    @InputFiles
    @Classpath
    @ApiStatus.Internal
    protected abstract ConfigurableFileCollection getRunnerClasspath()

    AbstractMDGConvertTask() {
        // default to e.g. build/modsDotGroovyToToml/mods.toml
        output.convention(projectLayout.buildDirectory.dir('generated/modsDotGroovy/' + name.replaceFirst('ConvertTo', 'modsDotGroovyTo')).map((Directory dir) -> dir.file(outputName.get())))
        output.finalizeValueOnRead()

        projectVersion.convention(project.provider(() -> project.version.toString()))
        projectGroup.convention(project.provider(() -> project.group.toString()))
        isMultiplatform.convention(project.provider(() -> false))

        runnerClasspath.from(project.configurations.maybeCreate('modsDotGroovyRunnerClasspath'))
    }

    protected abstract String writeData(Map data)

    @TaskAction
    void run() {
        final input = input.get().asFile
        if (!input.exists()) {
            logger.warn("Input file {} for task '{}' could not be found!", input, name)
            return
        }

        final Map data = FilteredStream.convertToSerializable(from(input))

        final outPath = output.get().asFile.toPath()
        if (outPath.parent !== null && !Files.exists(outPath.parent))
            Files.createDirectories(outPath.parent)

        Files.deleteIfExists(outPath)
        Files.writeString(outPath, writeData(data))
    }

    protected Map from(File script) {
        Map bindingValues = [
                buildProperties: buildProperties.get(),
                version: projectVersion.get(),
                group: projectGroup.get(),
        ]

        final json = new JsonSlurper()
        bindingValues = MapUtils.recursivelyMergeOnlyMaps(bindingValues, json.parse(platformDetailsFile.get().asFile) as Map)

        return convertService.get().run(getRunnerClasspath().getAsPath(), mdgRuntimeFiles.files.collect { it.toURI().toURL() }.toArray(URL[]::new), script, platform.get(), isMultiplatform.get(), FilteredStream.convertToSerializable(bindingValues) as Map<String, Object>)
    }
}
